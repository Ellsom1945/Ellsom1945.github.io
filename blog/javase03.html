<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>设计模式之单例模式 | EllsomBlog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/images/logo.jpg">
    <link rel="manifest" href="/images/logo.jpg">
    <link rel="apple-touch-icon" href="/images/logo.jpg">
    <meta name="description" content="SURVIVE！">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.cf1d2abd.css" as="style"><link rel="preload" href="/assets/js/app.9278fbc6.js" as="script"><link rel="preload" href="/assets/js/3.138a8b77.js" as="script"><link rel="preload" href="/assets/js/1.001dc366.js" as="script"><link rel="preload" href="/assets/js/17.b0928481.js" as="script"><link rel="prefetch" href="/assets/js/10.7aa5717e.js"><link rel="prefetch" href="/assets/js/11.7788859a.js"><link rel="prefetch" href="/assets/js/12.de5b48bd.js"><link rel="prefetch" href="/assets/js/13.0b6f0e8c.js"><link rel="prefetch" href="/assets/js/14.d16d9a6b.js"><link rel="prefetch" href="/assets/js/15.5f092d60.js"><link rel="prefetch" href="/assets/js/16.df41182e.js"><link rel="prefetch" href="/assets/js/18.cae66e94.js"><link rel="prefetch" href="/assets/js/19.b85df8df.js"><link rel="prefetch" href="/assets/js/20.80a9894a.js"><link rel="prefetch" href="/assets/js/21.3419ab9e.js"><link rel="prefetch" href="/assets/js/22.f5df4a37.js"><link rel="prefetch" href="/assets/js/23.53d5da38.js"><link rel="prefetch" href="/assets/js/24.b7b5759f.js"><link rel="prefetch" href="/assets/js/25.42a5e72c.js"><link rel="prefetch" href="/assets/js/26.0b476650.js"><link rel="prefetch" href="/assets/js/27.d2f0a7bb.js"><link rel="prefetch" href="/assets/js/28.5b615999.js"><link rel="prefetch" href="/assets/js/29.7d7299eb.js"><link rel="prefetch" href="/assets/js/30.0d398a7a.js"><link rel="prefetch" href="/assets/js/31.5cf13050.js"><link rel="prefetch" href="/assets/js/32.93406ba1.js"><link rel="prefetch" href="/assets/js/33.52f37aca.js"><link rel="prefetch" href="/assets/js/34.c1675fa5.js"><link rel="prefetch" href="/assets/js/35.22b4313f.js"><link rel="prefetch" href="/assets/js/36.6443bdaa.js"><link rel="prefetch" href="/assets/js/37.090ca1e5.js"><link rel="prefetch" href="/assets/js/38.b80a04f5.js"><link rel="prefetch" href="/assets/js/39.1787554f.js"><link rel="prefetch" href="/assets/js/4.f67fe07c.js"><link rel="prefetch" href="/assets/js/40.d80a936d.js"><link rel="prefetch" href="/assets/js/41.60758a6a.js"><link rel="prefetch" href="/assets/js/42.131e4c69.js"><link rel="prefetch" href="/assets/js/43.d1601464.js"><link rel="prefetch" href="/assets/js/44.8c819dbb.js"><link rel="prefetch" href="/assets/js/45.1029424e.js"><link rel="prefetch" href="/assets/js/5.545acc8e.js"><link rel="prefetch" href="/assets/js/6.584550b3.js"><link rel="prefetch" href="/assets/js/7.1f69e490.js"><link rel="prefetch" href="/assets/js/8.953c27af.js"><link rel="prefetch" href="/assets/js/9.9be1b2f7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cf1d2abd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>EllsomBlog</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>SURVIVE！</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">EllsomBlog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      blog
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/tech/" class="nav-link"><i class="undefined"></i>
  技术
</a></li><li class="dropdown-item"><!----> <a href="/categories/literature/" class="nav-link"><i class="undefined"></i>
  文学
</a></li><li class="dropdown-item"><!----> <a href="/categories/philo/" class="nav-link"><i class="undefined"></i>
  哲学
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  杂谈
</a></li></ul></div></div><div class="nav-item"><a href="/categories/diary/" class="nav-link"><i class="iconfont reco-document"></i>
  diary
</a></div><div class="nav-item"><a href="/categories/leetcode/" class="nav-link"><i class="iconfont reco-blog"></i>
  leetcode笔记
</a></div><div class="nav-item"><a href="/blog/mdref.html" class="nav-link"><i class="iconfont reco-api"></i>
  markdown
</a></div><div class="nav-item"><a href="https://github.com/Ellsom1945" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  timeline
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/images/logo.jpg" alt="author-avatar" class="personal-img" data-v-828910c6> <!----> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>35</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>31</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6><li class="social-item" data-v-828910c6><i class="iconfont reco-github" style="color:#abbd81;" data-v-828910c6></i></li><li class="social-item" data-v-828910c6><i class="iconfont reco-csdn" style="color:#f47e60;" data-v-828910c6></i></li><li class="social-item" data-v-828910c6><i class="iconfont reco-v2ex" style="color:#f8b26a;" data-v-828910c6></i></li></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      blog
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/tech/" class="nav-link"><i class="undefined"></i>
  技术
</a></li><li class="dropdown-item"><!----> <a href="/categories/literature/" class="nav-link"><i class="undefined"></i>
  文学
</a></li><li class="dropdown-item"><!----> <a href="/categories/philo/" class="nav-link"><i class="undefined"></i>
  哲学
</a></li><li class="dropdown-item"><!----> <a href="/categories/else/" class="nav-link"><i class="undefined"></i>
  杂谈
</a></li></ul></div></div><div class="nav-item"><a href="/categories/diary/" class="nav-link"><i class="iconfont reco-document"></i>
  diary
</a></div><div class="nav-item"><a href="/categories/leetcode/" class="nav-link"><i class="iconfont reco-blog"></i>
  leetcode笔记
</a></div><div class="nav-item"><a href="/blog/mdref.html" class="nav-link"><i class="iconfont reco-api"></i>
  markdown
</a></div><div class="nav-item"><a href="https://github.com/Ellsom1945" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  timeline
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>设计模式之单例模式</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">设计模式之单例模式</h1> <div data-v-1ff7123e><!----> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>4/10/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>设计模式</span><span class="tag-item" data-v-1ff7123e>懒汉式</span><span class="tag-item" data-v-1ff7123e>饿汉式</span><span class="tag-item" data-v-1ff7123e>单例模式</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="单例模式"><a href="#单例模式" class="header-anchor">#</a> 单例模式</h1> <ul><li>单例创建模式是一个通用的编程习语。和多线程一起使用时，必需使用某种类型的同步。在努力创建更有效的代码时，Java 程序员们创建了双重检查锁定习语，将其和单例创建模式一起使用，从而限制同步代码量。然而，由于一些不太常见的 Java 内存模型细节的原因，并不能保证这个双重检查锁定习语有效。</li> <li>它偶尔会失败，而不是总失败。此外，它失败的原因并不明显，还包含 Java 内存模型的一些隐秘细节。这些事实将导致代码失败，原因是双重检查锁定难于跟踪。在本文余下的部分里，我们将详细介绍双重检查锁定习语，从而理解它在何处失效。</li></ul> <p>要理解双重检查锁定习语是从哪里起源的，就必须理解通用单例创建习语，如清单 1 中的阐释：</p> <h3 id="清单-1-单例创建习语-懒汉式"><a href="#清单-1-单例创建习语-懒汉式" class="header-anchor">#</a> 清单 1. 单例创建习语(懒汉式)</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Singleton</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">Vector</span> v<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">boolean</span> inUse<span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">addElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    inUse <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          <span class="token comment">//1</span>
      instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>               <span class="token comment">//3</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>​		此类的设计确保只创建一个 Singleton 对象。构造函数被声明为 private，getInstance() 方法只创建一个对象。这个实现适合于单线程程序。然而，当引入多线程时，就必须通过同步来保护 getInstance() 方法。如果不保护 getInstance() 方法，则可能返回Singleton 对象的两个不同的实例。假设两个线程并发调用 getInstance() 方法并且按以下顺序执行调用：</p> <div class="language-markdown line-numbers-mode"><pre class="language-markdown"><code><span class="token list punctuation">1.</span> 线程 1 调用 getInstance() 方法并决定 instance 在 //1 处为 null。 

<span class="token list punctuation">2.</span> 线程 1 进入 if 代码块，但在执行 //2 处的代码行时被线程 2 预占。 

<span class="token list punctuation">3.</span> 线程 2 调用 getInstance() 方法并在 //1 处决定 instance 为 null。 

<span class="token list punctuation">4.</span> 线程 2 进入 if 代码块并创建一个新的 Singleton 对象并在 //2 处将变量 instance 分配给这个新对象。 

<span class="token list punctuation">5.</span> 线程 2 在 //3 处返回 Singleton 对象引用。

<span class="token list punctuation">6.</span> 线程 2 被线程 1 预占。 

<span class="token list punctuation">7.</span> 线程 1 在它停止的地方启动，并执行 //2 代码行，这导致创建另一个 Singleton 对象。 

<span class="token list punctuation">8.</span> 线程 1 在 //3 处返回这个对象。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>​		结果是 <code>getInstance()</code> 方法创建了两个 <code>Singleton</code> 对象，而它本该只创建一个对象。通过同步 <code>getInstance()</code> 方法从而在同一时间只允许一个线程执行代码，这个问题得以改正，如清单 2 所示：</p> <h3 id="清单-2-线程安全的-getinstance-方法"><a href="#清单-2-线程安全的-getinstance-方法" class="header-anchor">#</a> 清单 2. 线程安全的 getInstance() 方法</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          <span class="token comment">//1</span>
    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//2</span>
  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>               <span class="token comment">//3</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​		清单 2 中的代码针对多线程访问 getInstance() 方法运行得很好。然而，当分析这段代码时，您会意识到只有在第一次调用方法时才需要同步。由于只有第一次调用执行了 //2 处的代码，而只有此行代码需要同步，因此就无需对后续调用使用同步。所有其他调用用于决定 instance 是非 null 的，并将其返回。多线程能够安全并发地执行除第一次调用外的所有调用。尽管如此，由于该方法是synchronized 的，需要为该方法的每一次调用付出同步的代价，即使只有第一次调用需要同步。</p> <p>​		为使此方法更为有效，一个被称为双重检查锁定的习语就应运而生了。这个想法是为了避免对除第一次调用外的所有调用都实行同步的昂贵代价。同步的代价在不同的 JVM 间是不同的。在早期，代价相当高。随着更高级的 JVM 的出现，同步的代价降低了，但出入synchronized 方法或块仍然有性能损失。不考虑 JVM 技术的进步，程序员们绝不想不必要地浪费处理时间。</p> <p>​		因为只有清单 2 中的 //2 行需要同步，我们可以只将其包装到一个同步块中，如清单 3 所示：</p> <h3 id="清单-3-getinstance-方法"><a href="#清单-3-getinstance-方法" class="header-anchor">#</a> 清单 3. getInstance() 方法</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​		清单 3 中的代码展示了用多线程加以说明的和清单 1 相同的问题。当 instance 为 null 时，两个线程可以并发地进入 if 语句内部。然后，一个线程进入 synchronized 块来初始化 instance，而另一个线程则被阻断。当第一个线程退出 synchronized 块时，等待着的线程进入并创建另一个 Singleton 对象。注意：当第二个线程进入 synchronized 块时，它并没有检查 instance 是否非 null。</p> <p>​		<strong>双重检查锁定</strong></p> <p>​		为处理清单 3 中的问题，我们需要对 <code>instance</code> 进行第二次检查。这就是“双重检查锁定”名称的由来。将双重检查锁定习语应用到清单 3 的结果就是清单 4 。</p> <h3 id="清单-4-双重检查锁定示例"><a href="#清单-4-双重检查锁定示例" class="header-anchor">#</a> 清单 4. 双重检查锁定示例</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//1</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          <span class="token comment">//2</span>
        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//3</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​		双重检查锁定背后的理论是：在 //2 处的第二次检查使（如清单 3 中那样）创建两个不同的 <code>Singleton</code> 对象成为不可能。假设有下列事件序列：</p> <div class="language-markdown line-numbers-mode"><pre class="language-markdown"><code><span class="token list punctuation">1.</span> 线程 1 进入 getInstance() 方法。 

<span class="token list punctuation">2.</span> 由于 instance 为 null，线程 1 在 //1 处进入 synchronized 块。 

<span class="token list punctuation">3.</span> 线程 1 被线程 2 预占。

<span class="token list punctuation">4.</span> 线程 2 进入 getInstance() 方法。

<span class="token list punctuation">5.</span> 由于 instance 仍旧为 null，线程 2 试图获取 //1 处的锁。然而，由于线程 1 持有该锁，线程 2 在 //1 处阻塞。

<span class="token list punctuation">6.</span> 线程 2 被线程 1 预占。

<span class="token list punctuation">7.</span> 线程 1 执行，由于在 //2 处实例仍旧为 null，线程 1 还创建一个 Singleton 对象并将其引用赋值给 instance。

<span class="token list punctuation">8.</span> 线程 1 退出 synchronized 块并从 getInstance() 方法返回实例。 

<span class="token list punctuation">9.</span> 线程 1 被线程 2 预占。

<span class="token list punctuation">10.</span> 线程 2 获取 //1 处的锁并检查 instance 是否为 null。 

<span class="token list punctuation">11.</span> 由于 instance 是非 null 的，并没有创建第二个 Singleton 对象，由线程 1 创建的对象被返回。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>​		双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong></p> <p>​		<strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong></p> <p>​		<em><strong>无序写入</strong></em></p> <p>​		为解释该问题，需要重新考察上述清单 4 中的 //3 行。此行代码创建了一个 Singleton 对象并初始化变量 instance 来引用此对象。这行代码的问题是：在 Singleton 构造函数体执行之前，变量 instance 可能成为非 null 的。</p> <p>​		什么？这一说法可能让您始料未及，但事实确实如此。在解释这个现象如何发生前，请先暂时接受这一事实，我们先来考察一下双重检查锁定是如何被破坏的。假设清单 4 中代码执行以下事件序列：</p> <div class="language-markdown line-numbers-mode"><pre class="language-markdown"><code><span class="token list punctuation">1.</span> 线程 1 进入 getInstance() 方法。

<span class="token list punctuation">2.</span> 由于 instance 为 null，线程 1 在 //1 处进入 synchronized 块。 

<span class="token list punctuation">3.</span> 线程 1 前进到 //3 处，但在构造函数执行之前，使实例成为非 null。 

<span class="token list punctuation">4.</span> 线程 1 被线程 2 预占。

<span class="token list punctuation">5.</span> 线程 2 检查实例是否为 null。因为实例不为 null，线程 2 将 instance 引用返回给一个构造完整但部分初始化了的 Singleton对象。 

<span class="token list punctuation">6.</span> 线程 2 被线程 1 预占。

<span class="token list punctuation">7.</span> 线程 1 通过运行 Singleton 对象的构造函数并将引用返回给它，来完成对该对象的初始化。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​		此事件序列发生在线程 2 返回一个尚未执行构造函数的对象的时候。</p> <p>为展示此事件的发生情况，假设为代码行 <code>instance =new Singleton();</code> 执行了下列伪代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>mem <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//Allocate memory for Singleton object.</span>
instance <span class="token operator">=</span> mem<span class="token punctuation">;</span>               <span class="token comment">//Note that instance is now non-null, but</span>
                              <span class="token comment">//has not been initialized.</span>
<span class="token function">ctorSingleton</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//Invoke constructor for Singleton passing</span>
                              <span class="token comment">//instance.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​		这段伪代码不仅是可能的，而且是一些 JIT 编译器上真实发生的。执行的顺序是颠倒的，但鉴于当前的内存模型，这也是允许发生的。JIT 编译器的这一行为使双重检查锁定的问题只不过是一次学术实践而已。</p> <p>​		为说明这一情况，假设有清单 5 中的代码。它包含一个剥离版的 getInstance() 方法。我已经删除了“双重检查性”以简化我们对生成的汇编代码（清单 6）的回顾。我们只关心 JIT 编译器如何编译 instance=new Singleton(); 代码。此外，我提供了一个简单的构造函数来明确说明汇编代码中该构造函数的运行情况。</p> <h3 id="清单-5-用于演示无序写入的单例类"><a href="#清单-5-用于演示无序写入的单例类" class="header-anchor">#</a> <strong>清单 5. 用于演示无序写入的单例类</strong></h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Singleton</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">boolean</span> inUse<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>  

  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    inUse <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    val <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>​		清单 6 包含由 Sun JDK 1.2.1 JIT 编译器为清单 5 中的 <code>getInstance()</code> 方法体生成的汇编代码。</p> <h3 id="清单-6-由清单-5-中的代码生成的汇编代码"><a href="#清单-6-由清单-5-中的代码生成的汇编代码" class="header-anchor">#</a> 清单 6. 由清单 5 中的代码生成的汇编代码</h3> <div class="language-assembly line-numbers-mode"><pre class="language-text"><code>;asm code generated for getInstance
054D20B0   mov         eax,[049388C8]      ;load instance ref
054D20B5   test        eax,eax             ;test for null
054D20B7   jne         054D20D7
054D20B9   mov         eax,14C0988h
054D20BE   call        503EF8F0            ;allocate memory
054D20C3   mov         [049388C8],eax      ;store pointer in 
                                           ;instance ref. instance  
                                           ;non-null and ctor
                                           ;has not run
054D20C8   mov         ecx,dword ptr [eax] 
054D20CA   mov         dword ptr [ecx],1   ;inline ctor - inUse=true;
054D20D0   mov         dword ptr [ecx+4],5 ;inline ctor - val=5;
054D20D7   mov         ebx,dword ptr ds:[49388C8h]
054D20DD   jmp         054D20B0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>​		<strong>注:</strong> 为引用下列说明中的汇编代码行，我将引用指令地址的最后两个值，因为它们都以 <code>054D20</code> 开头。例如，<code>B5</code> 代表 <code>test eax,eax</code>。</p> <p>​		汇编代码是通过运行一个在无限循环中调用 getInstance() 方法的测试程序来生成的。程序运行时，请运行 Microsoft Visual C++ 调试器并将其附到表示测试程序的 Java 进程中。然后，中断执行并找到表示该无限循环的汇编代码。</p> <p>​		B0 和 B5 处的前两行汇编代码将 instance 引用从内存位置 049388C8 加载至 eax 中，并进行 null 检查。这跟清单 5 中的getInstance() 方法的第一行代码相对应。第一次调用此方法时，instance 为 null，代码执行到 B9。BE 处的代码为 Singleton 对象从堆中分配内存，并将一个指向该块内存的指针存储到 eax 中。下一行代码，C3，获取 eax 中的指针并将其存储回内存位置为049388C8 的实例引用。结果是，instance 现在为非 null 并引用一个有效的 Singleton 对象。然而，此对象的构造函数尚未运行，这恰是破坏双重检查锁定的情况。然后，在 C8 行处，instance 指针被解除引用并存储到 ecx。CA 和 D0 行表示内联的构造函数，该构造函数将值 true 和 5 存储到 Singleton 对象。如果此代码在执行 C3 行后且在完成该构造函数前被另一个线程中断，则双重检查锁定就会失败。</p> <p>​		不是所有的 JIT 编译器都生成如上代码。一些生成了代码，从而只在构造函数执行后使 instance 成为非 null。针对 Java 技术的 IBM SDK 1.3 版和 Sun JDK 1.3 都生成这样的代码。然而，这并不意味着应该在这些实例中使用双重检查锁定。该习语失败还有一些其他原因。此外，您并不总能知道代码会在哪些 JVM 上运行，而 JIT 编译器总是会发生变化，从而生成破坏此习语的代码。</p> <p>​		双重检查锁定：获取两个</p> <p>​		考虑到当前的双重检查锁定不起作用，我加入了另一个版本的代码，如清单 7 所示，从而防止您刚才看到的无序写入问题。</p> <h3 id="清单-7-解决无序写入问题的尝试"><a href="#清单-7-解决无序写入问题的尝试" class="header-anchor">#</a> 清单 7. 解决无序写入问题的尝试</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//1</span>
      <span class="token class-name">Singleton</span> inst <span class="token operator">=</span> instance<span class="token punctuation">;</span>         <span class="token comment">//2</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>inst <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//3</span>
          inst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4</span>
        <span class="token punctuation">}</span>
        instance <span class="token operator">=</span> inst<span class="token punctuation">;</span>                 <span class="token comment">//5</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>​		看着清单 7 中的代码，您应该意识到事情变得有点荒谬。请记住，创建双重检查锁定是为了避免对简单的三行 getInstance() 方法实现同步。清单 7 中的代码变得难于控制。另外，该代码没有解决问题。仔细检查可获悉原因。</p> <p>​		此代码试图避免无序写入问题。它试图通过引入局部变量 inst 和第二个 synchronized 块来解决这一问题。该理论实现如下：</p> <div class="language-markdown line-numbers-mode"><pre class="language-markdown"><code><span class="token list punctuation">1.</span> 线程 1 进入 getInstance() 方法。

<span class="token list punctuation">2.</span> 由于 instance 为 null，线程 1 在 //1 处进入第一个 synchronized 块。 

<span class="token list punctuation">3.</span> 局部变量 inst 获取 instance 的值，该值在 //2 处为 null。 

<span class="token list punctuation">4.</span> 由于 inst 为 null，线程 1 在 //3 处进入第二个 synchronized 块。 

<span class="token list punctuation">5.</span> 线程 1 然后开始执行 //4 处的代码，同时使 inst 为非 null，但在 Singleton 的构造函数执行前。（这就是我们刚才看到的无序写入问题。） 

<span class="token list punctuation">6.</span> 线程 1 被线程 2 预占。

<span class="token list punctuation">7.</span> 线程 2 进入 getInstance() 方法。

<span class="token list punctuation">8.</span> 由于 instance 为 null，线程 2 试图在 //1 处进入第一个 synchronized 块。由于线程 1 目前持有此锁，线程 2 被阻断。

<span class="token list punctuation">9.</span> 线程 1 然后完成 //4 处的执行。

<span class="token list punctuation">10.</span> 线程 1 然后将一个构造完整的 Singleton 对象在 //5 处赋值给变量 instance，并退出这两个 synchronized 块。 

<span class="token list punctuation">11.</span> 线程 1 返回 instance。

<span class="token list punctuation">12.</span> 然后执行线程 2 并在 //2 处将 instance 赋值给 inst。

<span class="token list punctuation">13.</span> 线程 2 发现 instance 为非 null，将其返回。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>​		这里的关键行是 //5。此行应该确保 instance 只为 null 或引用一个构造完整的 Singleton 对象。该问题发生在理论和实际彼此背道而驰的情况下。</p> <p>由于当前内存模型的定义，清单 7 中的代码无效。Java 语言规范（Java Language Specification，JLS）要求不能将 synchronized块中的代码移出来。但是，并没有说不能将 synchronized 块外面的代码移入 synchronized 块中。</p> <p>JIT 编译器会在这里看到一个优化的机会。此优化会删除 //4 和 //5 处的代码，组合并且生成清单 8 中所示的代码。</p> <h3 id="清单-8-从清单-7-中优化来的代码。"><a href="#清单-8-从清单-7-中优化来的代码。" class="header-anchor">#</a> 清单 8. 从清单 7 中优化来的代码。</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//1</span>
      <span class="token class-name">Singleton</span> inst <span class="token operator">=</span> instance<span class="token punctuation">;</span>         <span class="token comment">//2</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>inst <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//3</span>
          <span class="token comment">//inst = new Singleton();      //4</span>
          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               
        <span class="token punctuation">}</span>
        <span class="token comment">//instance = inst;               //5</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>​		如果进行此项优化，您将同样遇到我们之前讨论过的无序写入问题。</p> <p>​		<strong>用 volatile 声明每一个变量怎么样？</strong></p> <p>​		另一个想法是针对变量 inst 以及 instance 使用关键字 volatile。根据 JLS（参见 参考资料），声明成 volatile 的变量被认为是顺序一致的，即，不是重新排序的。但是试图使用 volatile 来修正双重检查锁定的问题，会产生以下两个问题：</p> <div class="language-markdown line-numbers-mode"><pre class="language-markdown"><code><span class="token list punctuation">-</span> 这里的问题不是有关顺序一致性的，而是代码被移动了，不是重新排序。

<span class="token list punctuation">-</span> <span class="token strike"><span class="token punctuation">~~</span><span class="token content">即使考虑了顺序一致性，大多数的 JVM 也没有正确地实现 volatile。</span><span class="token punctuation">~~</span></span>(tips:该问题在jdk1.5之后已经解决)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第二点值得展开讨论。假设有清单 9 中的代码：</p> <h3 id="清单-9-使用了-volatile-的顺序一致性"><a href="#清单-9-使用了-volatile-的顺序一致性" class="header-anchor">#</a> 清单 9. 使用了 volatile 的顺序一致性</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> test
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token comment">//This can happen second</span>
    stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//This can happen first</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span>
      num <span class="token operator">+=</span> num<span class="token punctuation">;</span>  <span class="token comment">//num can == 0!</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>​		<s>根据 JLS，由于 stop 和 num 被声明为 volatile，它们应该顺序一致。这意味着如果 stop 曾经是 true，num 一定曾被设置成 100。尽管如此，因为许多 JVM 没有实现 volatile 的顺序一致性功能，您就不能依赖此行为。因此，如果线程 1 调用 foo 并且线程 2 并发地调用 bar，则线程 1 可能在 num 被设置成为 100 之前将 stop 设置成 true。这将导致线程见到 stop 是 true，而 num 仍被设置成 0。使用 volatile 和 64 位变量的原子数还有另外一些问题，但这已超出了本文的讨论范围。</s></p> <p>​		<s><strong>解决方案</strong></s></p> <p>​		<s>底线就是：无论以何种形式，都不应使用双重检查锁定，因为您不能保证它在任何 JVM 实现上都能顺利运行。JSR-133 是有关内存模型寻址问题的，尽管如此，新的内存模型也不会支持双重检查锁定。因此，您有两种选择：</s></p> <p>​		<strong>tips:</strong></p> <p>​		这些问题在jdk1.5之后都被解决，详情参见<a href="https://blog.csdn.net/canot/article/details/51295228" target="_blank" rel="noopener noreferrer">博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-markdown line-numbers-mode"><pre class="language-markdown"><code><span class="token list punctuation">-</span> 接受如清单 2 中所示的 getInstance() 方法的同步。

<span class="token list punctuation">-</span> 放弃同步，而使用一个 static 字段。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		选择项 2 如清单 10 中所示:</p> <h3 id="清单-10-使用-static-字段的单例实现-饿汉式"><a href="#清单-10-使用-static-字段的单例实现-饿汉式" class="header-anchor">#</a> 清单 10. 使用 static 字段的单例实现(饿汉式)</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Singleton</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">Vector</span> v<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">boolean</span> inUse<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    inUse <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>​		清单 10 的代码没有使用同步，并且确保调用 <code>static getInstance()</code> 方法时才创建 <code>Singleton</code>。如果您的目标是消除同步，则这将是一个很好的选择。</p> <p>​		String 不是不变的</p> <p>​		鉴于无序写入和引用在构造函数执行前变成非 <code>null</code> 的问题，您可能会考虑 <code>String</code> 类。假设有下列代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">String</span> str<span class="token punctuation">;</span>
<span class="token comment">//...</span>
str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​		String 类应该是不变的。尽管如此，鉴于我们之前讨论的无序写入问题，那会在这里导致问题吗？答案是肯定的。考虑两个线程访问String str。一个线程能看见 str 引用一个 String 对象，在该对象中构造函数尚未运行。事实上，清单 11 包含展示这种情况发生的代码。注意，这个代码仅在我测试用的旧版 JVM 上会失败。IBM 1.3 和 Sun 1.3 JVM 都会如期生成不变的 String。</p> <h3 id="清单-11-可变-string-的例子"><a href="#清单-11-可变-string-的例子" class="header-anchor">#</a> 清单 11. 可变 String 的例子</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">StringCreator</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span>
<span class="token punctuation">{</span>
  <span class="token class-name">MutableString</span> ms<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">StringCreator</span><span class="token punctuation">(</span><span class="token class-name">MutableString</span> muts<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    ms <span class="token operator">=</span> muts<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
      ms<span class="token punctuation">.</span>str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">StringReader</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span>
<span class="token punctuation">{</span>
  <span class="token class-name">MutableString</span> ms<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">StringReader</span><span class="token punctuation">(</span><span class="token class-name">MutableString</span> muts<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    ms <span class="token operator">=</span> muts<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment">//2</span>
      <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;String is not immutable!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">MutableString</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> str<span class="token punctuation">;</span>                         <span class="token comment">//3</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token class-name">MutableString</span> ms <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutableString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//4</span>
    <span class="token keyword">new</span> <span class="token class-name">StringCreator</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//5</span>
    <span class="token keyword">new</span> <span class="token class-name">StringReader</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//6</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>​		此代码在 //4 处创建一个 MutableString 类，它包含了一个 String 引用，此引用由 //3 处的两个线程共享。在行 //5 和 //6 处，在两个分开的线程上创建了两个对象 StringCreator 和 StringReader。传入一个 MutableString 对象的引用。StringCreator 类进入到一个无限循环中并且使用值“hello”在 //1 处创建 String 对象。StringReader 也进入到一个无限循环中，并且在 //2 处检查当前的 String 对象的值是不是 “hello”。如果不行，StringReader 线程打印出一条消息并停止。如果 String 类是不变的，则从此程序应当看不到任何输出。如果发生了无序写入问题，则使 StringReader 看到 str 引用的惟一方法绝不是值为“hello”的 String 对象。</p> <p>​		在旧版的 JVM 如 Sun JDK 1.2.1 上运行此代码会导致无序写入问题。并因此导致一个非不变的 String。</p> <h3 id="结束语"><a href="#结束语" class="header-anchor">#</a> 结束语</h3> <p>​		为避免单例中代价高昂的同步，程序员非常聪明地发明了双重检查锁定习语。不幸的是，鉴于当前的内存模型的原因，该习语尚未得到广泛使用，就明显成为了一种不安全的编程结构。重定义脆弱的内存模型这一领域的工作正在进行中。尽管如此，即使是在新提议的内存模型中，双重检查锁定也是无效的。对此问题最佳的解决方案是接受同步或者使用一个 static field。</p> <h3 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h3> <p><a href="http://www.ibm.com/developerworks/java/library/j-dcl.html" target="_blank" rel="noopener noreferrer">英文原文<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129" target="_blank" rel="noopener noreferrer">参考博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-1-单例创建习语-懒汉式" class="sidebar-link reco-side-清单-1-单例创建习语-懒汉式" data-v-70334359>清单 1. 单例创建习语(懒汉式)</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-2-线程安全的-getinstance-方法" class="sidebar-link reco-side-清单-2-线程安全的-getinstance-方法" data-v-70334359>清单 2. 线程安全的 getInstance() 方法</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-3-getinstance-方法" class="sidebar-link reco-side-清单-3-getinstance-方法" data-v-70334359>清单 3. getInstance() 方法</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-4-双重检查锁定示例" class="sidebar-link reco-side-清单-4-双重检查锁定示例" data-v-70334359>清单 4. 双重检查锁定示例</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-5-用于演示无序写入的单例类" class="sidebar-link reco-side-清单-5-用于演示无序写入的单例类" data-v-70334359>清单 5. 用于演示无序写入的单例类</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-6-由清单-5-中的代码生成的汇编代码" class="sidebar-link reco-side-清单-6-由清单-5-中的代码生成的汇编代码" data-v-70334359>清单 6. 由清单 5 中的代码生成的汇编代码</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-7-解决无序写入问题的尝试" class="sidebar-link reco-side-清单-7-解决无序写入问题的尝试" data-v-70334359>清单 7. 解决无序写入问题的尝试</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-8-从清单-7-中优化来的代码。" class="sidebar-link reco-side-清单-8-从清单-7-中优化来的代码。" data-v-70334359>清单 8. 从清单 7 中优化来的代码。</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-9-使用了-volatile-的顺序一致性" class="sidebar-link reco-side-清单-9-使用了-volatile-的顺序一致性" data-v-70334359>清单 9. 使用了 volatile 的顺序一致性</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-10-使用-static-字段的单例实现-饿汉式" class="sidebar-link reco-side-清单-10-使用-static-字段的单例实现-饿汉式" data-v-70334359>清单 10. 使用 static 字段的单例实现(饿汉式)</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#清单-11-可变-string-的例子" class="sidebar-link reco-side-清单-11-可变-string-的例子" data-v-70334359>清单 11. 可变 String 的例子</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#结束语" class="sidebar-link reco-side-结束语" data-v-70334359>结束语</a></li><li class="level-3" data-v-70334359><a href="/blog/javase03.html#参考" class="sidebar-link reco-side-参考" data-v-70334359>参考</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.9278fbc6.js" defer></script><script src="/assets/js/3.138a8b77.js" defer></script><script src="/assets/js/1.001dc366.js" defer></script><script src="/assets/js/17.b0928481.js" defer></script>
  </body>
</html>
